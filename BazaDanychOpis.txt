Baza Danych Szpitala Psychiatrycznego - Opis
--------------------------------------------
Wiktoria Maciasz, Piotr Rywczak

1.	Cel
Celem stworzenia tej bazy danych jest uporządkowane przechowywanie informacji o pacjentach psychiatrycznych. Dzięki zapisywaniu dat ich pobytów w szpitalu jak i poszczególnych badań możliwe będzie łatwe śledzenie zmian ich stanu zdrowotnego podczas kolejnych hospitalizacji oraz zaplanowanie nowych efektywnych strategii. 

2.	Główne założenia
W bazie danych przechowywane będą głównie szczegółowe informacje z wszystkich pobytów hospitalizowanych pacjentów w szpitalu oraz powiązane z nimi istotne dane. 
Zapisywane będą wyniki pacjentów z badań podstawowych (badanie moczu, krwi) umożliwiające wykluczenie organicznego pochodzenia chorób psychicznych, a także nadzorowanie wielu chorób towarzyszących np. u pacjentów geriatrycznych oraz historia wagi (pomocna w kontrolowaniu wpływu wielu leków na wahania wagi, oraz podczas monitorowania pacjentów anorektycznych/bulimicznych). Dla wybranych pacjentów zapisane zostaną punkty oceny z poszczególnych skali psychologicznych (Test na depresję Becca, skala manii Young’a, Test osobowości MMPI2, Test na narkomanię DUDIT, Skala uzależnienia od alkoholu AUDIT, Skala objawów pozytywnych i negatywnych w schizofrenii PANNS).
W danej bazie danych możliwy będzie także wgląd do szczegółów strategii leczenia pacjentów psychiatrycznych – diagnoza chorób psychicznych, pojawiające się objawy chorobowe, stosowane leki i ich dawki, lekarz/lekarze prowadzący konkretnego pacjenta. Zamieszczona zostanie również informacja na temat palenia papierosów – będą to praktyczne dane, ponieważ uzależnienie od tytoniu dotyczy dużego odsetka pacjentów, a może wpływać na efektywność niektórych leków. 
Baza danych ułatwi także komunikację z rodziną pacjenta przechowując numery kontaktowe, adresy mailowe do wyznaczonych osób, a także – w razie potrzeby do nawiązania ponownego kontaktu z samym pacjentem. 
Lekarze korzystający z przechowywanych danych będą mogli wyświetlić informacje na temat tego czy dany pacjent jest ubezpieczony. Dostaną również wgląd do leków refundowanych, dostępnych w szpitalu, ich kategorii oraz do interakcji lekowych, w momencie, kiedy wprowadzać będą politerapię różnymi lekami. Jest to bardzo użyteczne, ponieważ niektóre leki psychiatryczne stosowane w połączeniu często mogą zmieniać swoją efektywność. Do bazy danych zostaną dodane wszystkie obserwowalne polekowe objawy uboczne – również do wglądu lekarzy w celu dopracowania odpowiedniego leczenia. Dodatkowo spisany zostanie dostawca leków wraz z firmą farmaceutyczną je produkującą, umożliwi to wgląd między innymi w minimalne różnice w produkcji.
Jako dodatkowe dane w bazie danych zostanie zamieszczony stanowisko i kontakt do pracowników szpitala w celu ułatwienia komunikacji, a także wiadomość na temat zapełnienia i organizacji poszczególnych oddziałów.

3.	Możliwości
Oprócz praktycznego użycia danej bazy w prowadzeniu historii chorób pacjentów, nadzorowania ich zmieniającego się stanu zdrowia w czasie i wykorzystaniu tej wiedzy w przyszłym doborze odpowiednich strategii leczenia, utworzenie tej bazy danych da wiele dodatkowych możliwości. Największą z nich będzie składowanie olbrzymiej ilości informacji na temat pacjentów – ich płci, wieku, wagi, diagnoz, objawów chorobowych i powiązaniu tych danych z skutecznymi strategiami leczenia – takie działanie umożliwi w przyszłości zbudowanie odpowiednich algorytmów proponujących pewne leki z przeliczoną proponowaną ich dawką. Lekarz będzie mógł zestawić swoje zamierzenia z zasugerowanym przez algorytm leczeniem.  

4.	Ograniczenia przyjęte przy projektowaniu
Podczas tworzenia tej bazy danych ograniczyliśmy się do przechowywania danych dotyczących przede wszystkim pacjentów psychiatrycznych. Tak, aby docelowymi odbiorcami korzystającym z składowanych informacji byli lekarze/pielęgniarki.
Nie skupiliśmy się szczegółowo na organizacji oddziałów szpitalnych, historii rachunkowej szpitala czy na sprawach organizacyjnych. Są to obszary istotne w funkcjonowaniu samego szpitala, ale nie należące do naszego obszaru zainteresowań, dotyczącego przede wszystkim pomocy w doborze odpowiednich strategii leczenia spośród dostępnego szerokiego wachlarza leków na rynku.

5.	Diagram ER

6.	Schemat bazy danych (diagram relacji)

7.	Dodatkowe więzy integralności danych

8.	Utworzone indeksy

9.	Opis stworzonych widoków/funkcji

  a. FUNKCJA WYLICZAJĄCA WIEK PACJENTA
Funkcja wyliczająca wiek pacjenta ma na celu zwracanie cały czas aktualnych danych - tak, aby nie trzeba było nieustannie modyfikować lat życia pacjenta przechowywanych w tabeli. Funkcja korzysta z daty urodzenia zapisanej w tabeli Pacjenci, jest poprawna co do dnia.
Jako że pożadanym wynikiem jest jedynie wiek, utworzona została funkcja skalarna:   
GO
Create function ObliczWiek(@idpacjenta INT) 
returns int 
as 
Begin 
    DECLARE @DataUro DATE
    SET @DataUro = (SELECT DataUrodzenia FROM Pacjenci WHERE ID =  @idpacjenta)
	IF MONTH(@DataUro) = MONTH(getdate()) and day(@DataUro)>day(getdate()) 
		return datediff(MONTH,@DataUro, getdate())/12 - 1
	return datediff(MONTH,@DataUro, getdate())/12
End
GO

  b. WIDOK PODAJĄCY INFORMACJE O DNIACH POBYTU W SZPITALU I LICZBIE HOSPITALIZACJI
Widok w łatwy sposób daje wgląd do liczby dni spędzonych w szpitalu podczas kolejnych hospitalizacji pacjentów. Informacja ta może być przydatna dla lekarzy, ponieważ daje głębszy wgląd w czas trwania leczenia i wskazówki na temat nawrotu choroby.
Dany widok łatwo jest otrzymać z wykorzystaniem fynkcji okna:
GO
CREATE VIEW Info_Pobyty AS
SELECT *,
	datediff(dd,DataPrzyjecia,DataWypisu) AS Dni,
    COUNT(*) OVER (PARTITION BY ID_pacjenta
		order by DataPrzyjecia
        RANGE BETWEEN unbounded preceding AND unbounded following) [Liczba pobytów ogółem] 
FROM Pobyty
GO

  c. WIDOK INFORMUJĄCY O WYPEŁNIENIU ODDZIALÓW SZPITALNYCH PRZEZ PACJENTÓW
W celu uniknięcia przechowywania nadmiaru niepotrzebnych danych w tabelach, stworzono widok ilustrujący obecne zapełnienie miejsc na oddziałach. Widok wyświetla aktualną liczbę osób na oddziale, liczbę wszystkich miejsc ogólem, a także liczbę miejsc pozostałych - wolnych, w ostatiej kolumnie wyświetlana jest pełna nazwa oddziału. Stworzenie widoku jest możliwe przez wgląd do historii leczenia pacjentów znajdującej się w tabeli "StrategieLeczenia" oraz tabeli "Oddziały", mieszczącej informacje na temat struktury szpitala. 
GO
CREATE VIEW DostepneMiejscaNaOddzialach AS
select count(*) as LiczbaOsobNaOddziale , t1.LiczbaWszystkichMiejsc, (t1.LiczbaWszystkichMiejsc-count(*)) AS PozostaleMiejsca ,t1.NazwaOddzialu from
(select ID_Pacjenta, o.IdOddzialu as ID_Oddzialu, MIN(o.NazwaOddzialy) AS NazwaOddzialu, MIN(o.LiczbaMiejsc) AS LiczbaWszystkichMiejsc
from StrategieLeczenia sl inner join oddzialy o
on o.IdOddzialu = sl.Id_Oddzialu
where DataZakonczenia is null
group by id_pacjenta, o.IdOddzialu) as t1
group by t1.ID_Oddzialu, t1.NazwaOddzialu, t1.LiczbaWszystkichMiejsc
GO


  d. WIDOK WYŚWIETLAJĄCY LEKARZY U ICH OBECNYCH PACJENTÓW
Widok zwraca przejrzystą tabelę z najbardziej istotnymi informacjami osobowymi (Imie, Nazwisko, Stanowisko, Stopien naukowy) na temat lekarzy, którzy obecnie prowadzą leczenie dla pacjentów. Dla pacjentów tabela zwraca midzy innymi unikatowy numer pesel. Odczytanie tabeli ułatwia kulumna 'Leczy' i zaznaczenie kierunku grotem strzalki. 
GO
CREATE VIEW vw_Pacjenci_Lekarzy AS
SELECT Pracownicy.Imie AS [Imie Lekarza], Pracownicy.Nazwisko [Nazwisko Lekarza], Pracownicy.Stanowisko, Pracownicy.StopienNaukowy, '=>' AS Leczy, Pacjenci.Imie [Imie Pacjenta], Pacjenci.Nazwisko [Nazwisko Pacjenta], Pacjenci.Pesel [PESEL Pacjenta]
FROM Pracownicy RIGHT JOIN StrategieLeczenia ON Pracownicy.ID = StrategieLeczenia.LekarzProwadzacy INNER JOIN Pacjenci ON StrategieLeczenia.ID_Pacjenta = Pacjenci.ID
GO


  e. FUNKCJA WYŚWIETLAJĄCA LEKARZA I JEGO OBECNYCH PACJENTÓW
Funkcja  o podobnym zadaniu jak wyżej.
Funkcja ta może pomóc w organizacji pracy w szpitalu, ponieważ wzrośnie świadomość rzeczywistego obłożenia pacjentami lekarzy. Do wygenerowania tych dnych zastosowano funkcję tablicową. 
GO
CREATE FUNCTION f_Pacjenci_Lekarza ( @imie VARCHAR(256), @nazwisko VARCHAR(256) )
RETURNS table
AS
RETURN
(SELECT Pracownicy.Imie AS [Imie Lekarza], Pracownicy.Nazwisko [Nazwisko Lekarza], Pracownicy.Stanowisko, Pracownicy.StopienNaukowy, '=>' AS Leczy, Pacjenci.Imie [Imie Pacjenta], Pacjenci.Nazwisko [Nazwisko Pacjenta], Pacjenci.Pesel [PESEL Pacjenta]
FROM Pracownicy RIGHT JOIN StrategieLeczenia ON Pracownicy.ID = StrategieLeczenia.LekarzProwadzacy INNER JOIN Pacjenci ON StrategieLeczenia.ID_Pacjenta = Pacjenci.ID
WHERE Pracownicy.ID IN (
SELECT Pracownicy.ID FROM Pracownicy
WHERE Pracownicy.Imie = @imie AND Pracownicy.Nazwisko = @nazwisko))
GO

  f. Widok zwracający częstość występowania danych jednostek chorobowych w szpitalu
Użyteczny widok wyświetlający podsumowanie danych z całego szpitala - select zwraca liczbę danych jednostek chorobowych w sumie. Pozwala to na lepsze rozporządzanie zamówieniami na leki i zatrudnieniem odpowiednich specjalistów.
Połączono tabele: 'Pacjenci', 'WszystkieChorobyPacjentów' (ponieważ jeden pacjent może mieć więcej niż jedną diagnozę) i 'Choroby', następnie wynik pogrupowano odpowiednio i wyświetlono interesujące dane.
GO
CREATE VIEW CzestoscWystepowaniaJednostekChoorbowych AS
SELECT COUNT(*) AS [Liczba Pacjentów], NazwaChoroby [Nazwa Choroby] FROM Pacjenci P
INNER JOIN 
WszystkieChorobyPacjentow WCP ON P.ID = WCP.ID_Pacjenta
INNER JOIN
Choroby C ON WCP.ID_Choroby=C.IDChoroby
GROUP BY NazwaChoroby
GO

  g. Widok ilustrujący najpopularniejsze leki używane przez lekarzy w terapii pacjentów w danym szpitalu
Do stworzenia tego wyniku połączono tabele 'StrategieLeczenia' przechowującą historię hospitalizacji pacjentów i poszczególnych ich lekarzy prowadzących, tabelę 'Leki' oraz 'Pracownicy', z której wydzielono tylko lekarzy. Operacje te miały na celu uzyskanie danych o popularności danych leków stosowanych w terapiach i wybieranych przez konkretnych lekarzy. Ma to na celu zwiększyć możliwości stosowania najbardziej odpowiednich medykamentów.    
GO
CREATE VIEW UzycieLekow AS
SELECT P.ID, P.Imie, P.Nazwisko, L.NazwaLeku, COUNT(NazwaLeku) Ilość FROM Pracownicy P
INNER JOIN StrategieLeczenia SL
ON P.ID=SL.LekarzProwadzacy
INNER JOIN Leki L ON L.ID= SL.ID_LEKU 
WHERE P.Stanowisko = 'Lekarz'
GROUP BY P.Nazwisko, L.NazwaLeku, P.ID, P.Imie
GO


  h. FUNKCJA pokazująca pacjenta i jego obecnych lekarzy
Funkcja ma na celu szybkie znalezienie lekarza prowadzącego wybranego pacjenta. 
GO
CREATE FUNCTION f_Lekarze_Pacjenta ( @imie VARCHAR(256), @nazwisko VARCHAR(256) )
RETURNS table
AS
RETURN
(SELECT Pracownicy.Imie AS [Imie Lekarza], Pracownicy.Nazwisko [Nazwisko Lekarza], Pracownicy.Stanowisko, Pracownicy.StopienNaukowy, '=>' AS Leczy, Pacjenci.Imie [Imie Pacjenta], Pacjenci.Nazwisko [Nazwisko Pacjenta], Pacjenci.Pesel [PESEL Pacjenta]
FROM Pracownicy RIGHT JOIN StrategieLeczenia ON Pracownicy.ID = StrategieLeczenia.LekarzProwadzacy INNER JOIN Pacjenci ON StrategieLeczenia.ID_Pacjenta = Pacjenci.ID
WHERE Pacjenci.ID IN (
SELECT Pacjenci.ID FROM Pacjenci
WHERE Pacjenci.Imie = @imie AND Pacjenci.Nazwisko = @nazwisko))
GO


10.	Opis procedur składowanych

	a. Procedura wylicza BMI dla danego pacjeta po wprowadzeniu jego ID oraz daty pomiaru, jest to możliwe ponieważ w tabeli Pacjenci jest zawarta informacja o wzroście w cm. 
GO
create proc bmi (@idpacjenta int, @data date) as 
    declare @waga FLOAT
    set @waga = (select waga from HistoriaWagi where id_pacjenta = @idpacjenta and datapomiaru = @data)
    declare @wzrost FLOAT 
    set @wzrost = (select wzrost from Pacjenci where id = @idpacjenta)
    declare @bmi FLOAT
    set @bmi= (@waga)/POWER((@wzrost/100),2)
    return @bmi 
GO


	b. Procedura sprawdzająca prawidłowość wyniku z badania moczu pacjenta. Konstrukcje warunkowe sprawdzają czy wynik pacjenta mieści się w zakresach normy.
GO
CREATE PROC WynikiMoczu (@id_pacjenta INT, @data DATE) AS
	DECLARE @Barwa VARCHAR(256) 
	SET @Barwa = (SELECT Barwa FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Barwa = 'słomkowy'
		PRINT 'Barwa moczu: Prawidłowa'
	ELSE
		PRINT 'Barwa moczu: Nieprawidłowa '
	DECLARE @Klarownosc BIT
	SET @Klarownosc = (SELECT Klarownosc FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Klarownosc = 1
		PRINT 'Klarowność moczu: Mocz klarowny'
	ELSE
		PRINT 'Klarowność moczu: Mocz nieklarowny'
	DECLARE @OdczynPh FLOAT
	SET @OdczynPh = (SELECT OdczynPh FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @OdczynPh >4.5 AND @OdczynPh <8 
		PRINT 'Odczyn pH moczu: Prawidłowy'
	ELSE
		PRINT 'Odczyn pH moczu: Nierawidłowy'
	DECLARE @CiezarMoczu FLOAT
	SET @CiezarMoczu = (SELECT CiezarMoczu FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @CiezarMoczu >1.005 AND @CiezarMoczu <1.035
		PRINT 'Ciężar moczu: Prawidłowy'
	ELSE
		PRINT 'Ciężar moczu: Nierawidłowy'	
	DECLARE @Leukocyty BIT
	SET @Leukocyty = (SELECT Leukocyty FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Leukocyty = 0
		PRINT 'Brak obecności leukocytów w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność leukocytów w moczu - wynik nieprawidłowy'
	DECLARE @Hemoglobina BIT
	SET @Hemoglobina = (SELECT Hemoglobina FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Hemoglobina = 0
		PRINT 'Brak obecności hemoglobiny w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność hemoglobiny w moczu - wynik nieprawidłowy'
	DECLARE @Bilirubina BIT
	SET @Bilirubina = (SELECT Bilirubina FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Bilirubina = 0
		PRINT 'Brak obecności bilirubiny w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność bilirubiny w moczu - wynik nieprawidłowy'
	DECLARE @Urobilinogen BIT
	SET @Urobilinogen = (SELECT Urobilinogen FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Urobilinogen = 0
		PRINT 'Brak obecności urobilinogenu w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność urobilinogenu w moczu - wynik nieprawidłowy'
	DECLARE @Bialko BIT
	SET @Bialko = (SELECT Bialko FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Bialko = 0
		PRINT 'Brak obecności białka w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność białka w moczu - wynik nieprawidłowy'
	DECLARE @Glukoza BIT
	SET @Glukoza = (SELECT Glukoza FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Glukoza = 0
		PRINT 'Brak obecności glukozy w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność glukozy w moczu - wynik nieprawidłowy'
	DECLARE @Ketony BIT
	SET @Ketony = (SELECT Ketony FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Ketony = 0
		PRINT 'Brak obecności ketonów w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność ketonów w moczu - wynik nieprawidłowy'
	DECLARE @Azotyny BIT
	SET @Azotyny = (SELECT Azotyny FROM BadanieMoczu WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @data)
	IF @Azotyny = 0
		PRINT 'Brak obecności azotynów w moczu - wynik prawidłowy'
	ELSE
		PRINT 'Obecność azotynów w moczu - wynik nieprawidłowy' 
GO



	c. Procedura zwracająca prawidłowość wyników krwi pacjentów - procedura bierze poprawkę na wyznaczone normy osobno dla mężczyzn i kobiet.
GO
CREATE PROC WynikiKrwi (@id_pacjenta INT, @dataczas DATETIME) AS
	DECLARE @Erytrocyty FLOAT
	DECLARE @plec VARCHAR(256)
	SET @Erytrocyty = (SELECT Erytrocyty FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	SET @plec = (SELECT plec FROM Pacjenci WHERE ID = @id_pacjenta)
	IF (@Erytrocyty BETWEEN 3.5 AND 5.2 AND @plec='K') OR (@Erytrocyty BETWEEN 4.5 AND 5.4 AND @plec='M')
	PRINT('Liczba erytrocytów liczona w mln/mm3 - prawidłowa')
	ELSE
	PRINT('Liczba erytrocytów liczona w mln/mm3 - nieprawidłowa')	
	DECLARE @Leukocyty FLOAT
	SET @Leukocyty = (SELECT Leukocyty FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF @Leukocyty BETWEEN 4 AND 10
	PRINT('Liczba leukocytów liczona w tys./μl - prawidłowa')
	ELSE
	PRINT('Liczba leukocytów liczona w tys./μl - nieprawidłowa')
	DECLARE @Hemoglobina FLOAT
	SET @Hemoglobina = (SELECT Hemoglobina FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF (@Hemoglobina BETWEEN 12 AND 16 AND @plec='K') OR (@Hemoglobina BETWEEN 13 AND 18 AND @plec='M')
	PRINT('Ilość hemoglobiny liczona w g/dl - prawidłowa')
	ELSE
	PRINT('Ilość hemoglobiny liczona w g/dl - nieprawidłowa')	
	DECLARE @Hematokryt FLOAT
	SET @Hematokryt = (SELECT Hematokryt FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF (@Hematokryt BETWEEN 37 AND 47 AND @plec='K') OR (@Hematokryt BETWEEN 40 AND 50 AND @plec='M')
	PRINT('Hematokryt (%) prawidłowy')
	ELSE
	PRINT('Hematokryt (%) nieprawidłowy')	
	DECLARE @PlytkiKrwi FLOAT
	SET @PlytkiKrwi = (SELECT PlytkiKrwi FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF @PlytkiKrwi BETWEEN 150 AND 400
	PRINT('Liczba płytek krwi liczona w tys./μl - prawidłowa')
	ELSE
	PRINT('Liczba płytek krwi liczona w tys./μl - nieprawidłowa')
	DECLARE @Glukoza FLOAT
	SET @Glukoza = (SELECT Glukoza FROM BadanieKrwi WHERE ID_Pacjenta = @id_pacjenta AND DataBadania = @dataczas)
	IF @Glukoza BETWEEN 80 AND 140
	PRINT('Poziom glukozy (mg/dl) - prawidłowy')
	ELSE
	PRINT('Poziom glukozy (mg/dl) - nieprawidłowy')
GO


/*
Procedura oceniająca wyniki pacjenta w skali depresji Becca 
*/

GO
CREATE PROC TestBecca(@id_pacjenta INT, @data DATE) AS
    DECLARE @wynik INT
    SET @wynik = (SELECT TestBECCA FROM WynikiDanychPsychologicznych WHERE ID_Pacjenta = @id_pacjenta AND Data = @data)
    IF @wynik BETWEEN 0 AND 11
    PRINT 'brak depresji' 
    ELSE 
        IF @wynik BETWEEN 12 AND 19
        PRINT 'lekka depresja' 
        ELSE
            IF @wynik BETWEEN 20 AND 25
            PRINT 'umiarkowana depresja' 
            ELSE
                IF @wynik > 26 
                PRINT 'ciężka depresja' 
GO


/*
Procedura oceniająca epizod maniakalny w chorobie afektywnej dwubiegunowej za pomocą skali Younga
*/
GO
CREATE PROC SkalaYOUNGA(@id_pacjenta INT, @data DATE) AS
    DECLARE @wynik INT
    SET @wynik = (SELECT SkalaYounga FROM WynikiDanychPsychologicznych WHERE ID_Pacjenta = @id_pacjenta AND Data = @data)
    IF @wynik BETWEEN 0 AND 12
    PRINT 'remisja manii' 
    ELSE 
        IF @wynik BETWEEN 13 AND 19
        PRINT 'minimalne symptomy manii' 
        ELSE
            IF @wynik BETWEEN 20 AND 25
            PRINT 'hipomania' 
            ELSE
                IF @wynik BETWEEN 26 AND 37
                PRINT 'umiarkowana mania'
                ELSE
                    IF @wynik>37
                    PRINT 'ciężka mania'
GO


	d. Procedura oceniająca uzależnienie pacjenta od alkoholu z wykorzystaniem skali AUDIT;
GO
CREATE PROC SkalaAudit (@id_pacjenta INT, @data DATE) AS
    DECLARE @wynik INT
    SET @wynik = (SELECT SkalaAUDIT FROM WynikiDanychPsychologicznych WHERE ID_Pacjenta = @id_pacjenta AND Data = @data)
    IF @wynik >=8
    PRINT 'wskazane pogłębione badanie diagnostyczne u terapeuty uzależnień' 
    ELSE 
    PRINT 'wynik w normie' 
    RETURN @wynik
GO

	e. Procedura dodająca strategię leczenia dla danego pacjenta (imie, nazwisko, pesel) przypisując mu lekarza
GO
CREATE PROC DodajLeczenie(@imie_pacj VARCHAR(256), @nazwisko_pacj VARCHAR(256), @pesel_pacj VARCHAR(11), @imie_lek VARCHAR(256), @nazw_lek VARCHAR(256), @pesel_lek VARCHAR(11))
AS
	BEGIN
		DECLARE @id_pacj INT
		SELECT @id_pacj = Pacjenci.ID FROM Pacjenci WHERE Pacjenci.PESEL = @pesel_pacj

		DECLARE @id_lek INT
		SELECT @id_lek = Pracownicy.ID FROM Pracownicy WHERE Pracownicy.PESEL = @pesel_lek

		INSERT INTO StrategieLeczenia VALUES
		( @id_pacj, NULL, NULL, NULL, @id_lek, NULL, GETDATE(), NULL )

		SELECT * FROM StrategieLeczenia
	END
GO

	f) Procedura wpisująca detale leczenia
GO
CREATE PROC UzupelnijLeczenie ( @id_leczenia INT, @choroba VARCHAR(256), @lek VARCHAR(256), @dawka VARCHAR(256), @oddzial VARCHAR(256) )
AS
	BEGIN
		DECLARE @id_choroby INT
		SELECT @id_choroby = Choroby.ID FROM Choroby WHERE Choroby.NazwaChoroby = @choroba
		
		DECLARE @id_leku INT
		SELECT @id_leku = Leki.ID FROm Leki WHERE Leki.NazwaLeku = @lek

		DECLARE @id_oddzialu INT
		SELECT @id_oddzialu = Oddzialy.IdOddzialu FROm Oddzialy WHERE Oddzialy.NazwaOddzialy = @oddzial

		UPDATE StrategieLeczenia
		SET ID_Choroby = @id_choroby, ID_Leku = @id_leku, DawkaLeku = @dawka, ID_Oddzialu = @id_oddzialu
		WHERE ID = @id_leczenia

		SELECT * FROM StrategieLeczenia
	END
GO


	g) Procedura wpisująca datę końcową leczenia
GO
CREATE PROC ZakonczLeczenie (@id_leczenia INT)
AS
	BEGIN
	DECLARE @TEXT VARCHAR(256)
	IF (SELECT DataZakonczenia FROM StrategieLeczenia WHERE StrategieLeczenia.ID = @id_leczenia) IS NULL BEGIN
		UPDATE StrategieLeczenia
		SET DataZakonczenia = GETDATE()
		WHERE ID = @id_leczenia
		SET @TEXT = 'Leczenie zakonczone'
		END
	ELSE
		SET @TEXT = 'Leczenie już było zakonczone'

	PRINT ( @TEXT )
	SELECT * FROM StrategieLeczenia
	END
GO




11.	Opis wyzwalaczy

	a. Prosty wyzwalacz przekazujący informacje o update'owaniu pobytów pacjentów w szpitalu 
GO
CREATE TRIGGER TR_UPDATE_Pobyty ON Pobyty
AFTER UPDATE
AS
PRINT 'Zmodyfikowanio zawartość danych na temat pobytów pacjentów w szpitalu.'
SELECT * FROM deleted
SELECT * FROM inserted
GO

	b. Prosty wyzwalacz przekazujący informacje o dodaniu nowych pracowników szpitala
GO
CREATE TRIGGER TR_AFTER_INSERT_Pracownicy ON Pracownicy
AFTER INSERT
AS
PRINT 'Dodano nowego pracownika szpitala.'
SELECT * FROM inserted
GO

	c. Prosty wyzwalacz przekazujący informacje o dodaniu nowych diagnoz dla pacjentów
GO
CREATE TRIGGER TR_INSERT_WszystkieChorobyPacjentow ON WszystkieChorobyPacjentow
AFTER INSERT
AS
PRINT 'Dodano nową diagnozę.'
SELECT * FROM inserted
GO

	d. Prosty wyzwalacz przekazujący informacje o dodaniu nowej strategii leczenia

GO
CREATE TRIGGER TR_INSERT_StrategieLeczenia ON StrategieLeczenia
AFTER INSERT
AS
PRINT 'Dodano nową strategię leczenia pacjenta.'
SELECT * FROM inserted
GO


12.	Skrypt tworzący bazy danych

13.	Typowe zapytania

14. Strategie pielęgnacji bazy danych (kopie zapasowe)
W celu pielęgnaci bazy danych za pomocą SQL Server utworzono backup bazy danych pt. "BazaDanychSzpitala-KopiaZapasowa", który zapisano na dysku. Dodatkowym zabezpieczeniem jest przechowywanie Projektu w prywatnym repozytorium na Githubie.  
